import {
  __commonJS,
  __require,
  __toESM
} from "./chunk-BQWMX7FD.js";

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      throw new Error("unable to locate global object");
    };
    var global2 = getGlobal();
    module.exports = exports = global2.fetch;
    exports.default = global2.fetch.bind(global2);
    exports.Headers = global2.Headers;
    exports.Request = global2.Request;
    exports.Response = global2.Response;
  }
});

// node_modules/i18next-http-backend/lib/getFetch.cjs
var require_getFetch = __commonJS({
  "node_modules/i18next-http-backend/lib/getFetch.cjs"(exports, module) {
    var fetchApi2;
    if (typeof fetch === "function") {
      if (typeof global !== "undefined" && global.fetch) {
        fetchApi2 = global.fetch;
      } else if (typeof window !== "undefined" && window.fetch) {
        fetchApi2 = window.fetch;
      }
    }
    if (typeof __require !== "undefined") {
      f = fetchApi2 || require_browser();
      if (f.default)
        f = f.default;
      exports.default = f;
      module.exports = exports.default;
    }
    var f;
  }
});

// node_modules/i18next-http-backend/lib/utils.js
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0)
          obj[prop] = source[prop];
      }
    }
  });
  return obj;
}

// node_modules/i18next-http-backend/lib/request.js
var fetchNode = __toESM(require_getFetch(), 1);
var fetchApi;
if (typeof fetch === "function") {
  if (typeof global !== "undefined" && global.fetch) {
    fetchApi = global.fetch;
  } else if (typeof window !== "undefined" && window.fetch) {
    fetchApi = window.fetch;
  }
}
var XmlHttpRequestApi;
if (typeof XMLHttpRequest === "function") {
  if (typeof global !== "undefined" && global.XMLHttpRequest) {
    XmlHttpRequestApi = global.XMLHttpRequest;
  } else if (typeof window !== "undefined" && window.XMLHttpRequest) {
    XmlHttpRequestApi = window.XMLHttpRequest;
  }
}
var ActiveXObjectApi;
if (typeof ActiveXObject === "function") {
  if (typeof global !== "undefined" && global.ActiveXObject) {
    ActiveXObjectApi = global.ActiveXObject;
  } else if (typeof window !== "undefined" && window.ActiveXObject) {
    ActiveXObjectApi = window.ActiveXObject;
  }
}
if (!fetchApi && fetchNode)
  fetchApi = fetchNode.default || fetchNode;
var addQueryString = (url, params) => {
  if (params && typeof params === "object") {
    let queryString = "";
    for (const paramName in params) {
      queryString += "&" + encodeURIComponent(paramName) + "=" + encodeURIComponent(params[paramName]);
    }
    if (!queryString)
      return url;
    url = url + (url.indexOf("?") !== -1 ? "&" : "?") + queryString.slice(1);
  }
  return url;
};
var requestWithFetch = (options, url, payload, callback) => {
  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }
  const headers = { ...options.customHeaders || {} };
  if (payload)
    headers["Content-Type"] = "application/json";
  fetchApi(url, {
    method: payload ? "POST" : "GET",
    body: payload ? options.stringify(payload) : void 0,
    headers,
    ...typeof options.requestOptions === "function" ? options.requestOptions(payload) : options.requestOptions
  }).then((response) => {
    if (!response.ok)
      return callback(response.statusText || "Error", { status: response.status });
    response.text().then((data) => {
      callback(null, { status: response.status, data });
    }).catch(callback);
  }).catch(callback);
};
var requestWithXmlHttpRequest = (options, url, payload, callback) => {
  if (payload && typeof payload === "object") {
    payload = addQueryString("", payload).slice(1);
  }
  if (options.queryStringParams) {
    url = addQueryString(url, options.queryStringParams);
  }
  try {
    let x;
    if (XmlHttpRequestApi) {
      x = new XmlHttpRequestApi();
    } else {
      x = new ActiveXObjectApi("MSXML2.XMLHTTP.3.0");
    }
    x.open(payload ? "POST" : "GET", url, 1);
    if (!options.crossDomain) {
      x.setRequestHeader("X-Requested-With", "XMLHttpRequest");
    }
    x.withCredentials = !!options.withCredentials;
    if (payload) {
      x.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    }
    if (x.overrideMimeType) {
      x.overrideMimeType("application/json");
    }
    let h = options.customHeaders;
    h = typeof h === "function" ? h() : h;
    if (h) {
      for (var i in h) {
        x.setRequestHeader(i, h[i]);
      }
    }
    x.onreadystatechange = () => {
      x.readyState > 3 && callback(x.statusText, { status: x.status, data: x.responseText });
    };
    x.send(payload);
  } catch (e) {
    console && console.log(e);
  }
};
var request = (options, url, payload, callback) => {
  if (typeof payload === "function") {
    callback = payload;
    payload = void 0;
  }
  callback = callback || (() => {
  });
  if (fetchApi) {
    return requestWithFetch(options, url, payload, callback);
  }
  if (typeof XMLHttpRequest === "function" || typeof ActiveXObject === "function") {
    return requestWithXmlHttpRequest(options, url, payload, callback);
  }
};
var request_default = request;

// node_modules/i18next-http-backend/lib/index.js
var getDefaults = () => {
  return {
    loadPath: "/locales/{{lng}}/{{ns}}.json",
    addPath: "/locales/add/{{lng}}/{{ns}}",
    allowMultiLoading: false,
    parse: (data) => JSON.parse(data),
    stringify: JSON.stringify,
    parsePayload: (namespace, key, fallbackValue) => ({ [key]: fallbackValue || "" }),
    request: request_default,
    reloadInterval: false,
    customHeaders: {},
    queryStringParams: {},
    crossDomain: false,
    // used for XmlHttpRequest
    withCredentials: false,
    // used for XmlHttpRequest
    overrideMimeType: false,
    // used for XmlHttpRequest
    requestOptions: {
      // used for fetch
      mode: "cors",
      credentials: "same-origin",
      cache: "default"
    }
  };
};
var Backend = class {
  constructor(services, options = {}, allOptions = {}) {
    this.services = services;
    this.options = options;
    this.allOptions = allOptions;
    this.type = "backend";
    this.init(services, options, allOptions);
  }
  init(services, options = {}, allOptions = {}) {
    this.services = services;
    this.options = defaults(options, this.options || {}, getDefaults());
    this.allOptions = allOptions;
    if (this.options.reloadInterval) {
      setInterval(() => this.reload(), this.options.reloadInterval);
    }
  }
  readMulti(languages, namespaces, callback) {
    var loadPath = this.options.loadPath;
    if (typeof this.options.loadPath === "function") {
      loadPath = this.options.loadPath(languages, namespaces);
    }
    const url = this.services.interpolator.interpolate(loadPath, { lng: languages.join("+"), ns: namespaces.join("+") });
    this.loadUrl(url, callback, languages, namespaces);
  }
  read(language, namespace, callback) {
    var loadPath = this.options.loadPath;
    if (typeof this.options.loadPath === "function") {
      loadPath = this.options.loadPath([language], [namespace]);
    }
    const url = this.services.interpolator.interpolate(loadPath, { lng: language, ns: namespace });
    this.loadUrl(url, callback, language, namespace);
  }
  loadUrl(url, callback, languages, namespaces) {
    this.options.request(this.options, url, void 0, (err, res) => {
      if (res && res.status >= 500 && res.status < 600)
        return callback(
          "failed loading " + url,
          true
          /* retry */
        );
      if (res && res.status >= 400 && res.status < 500)
        return callback(
          "failed loading " + url,
          false
          /* no retry */
        );
      if (err)
        return callback(err, false);
      let ret, parseErr;
      try {
        ret = this.options.parse(res.data, languages, namespaces);
      } catch (e) {
        parseErr = "failed parsing " + url + " to json";
      }
      if (parseErr)
        return callback(parseErr, false);
      callback(null, ret);
    });
  }
  create(languages, namespace, key, fallbackValue) {
    if (!this.options.addPath)
      return;
    if (typeof languages === "string")
      languages = [languages];
    const payload = this.options.parsePayload(namespace, key, fallbackValue);
    languages.forEach((lng) => {
      const url = this.services.interpolator.interpolate(this.options.addPath, { lng, ns: namespace });
      this.options.request(this.options, url, payload, (data, res) => {
      });
    });
  }
  reload() {
    const { backendConnector, languageUtils, logger } = this.services;
    const currentLanguage = backendConnector.language;
    if (currentLanguage && currentLanguage.toLowerCase() === "cimode")
      return;
    const toLoad = [];
    const append = (lng) => {
      const lngs = languageUtils.toResolveHierarchy(lng);
      lngs.forEach((l) => {
        if (toLoad.indexOf(l) < 0)
          toLoad.push(l);
      });
    };
    append(currentLanguage);
    if (this.allOptions.preload)
      this.allOptions.preload.forEach((l) => append(l));
    toLoad.forEach((lng) => {
      this.allOptions.ns.forEach((ns) => {
        backendConnector.read(lng, ns, "read", null, null, (err, data) => {
          if (err)
            logger.warn(`loading namespace ${ns} for language ${lng} failed`, err);
          if (!err && data)
            logger.log(`loaded namespace ${ns} for language ${lng}`, data);
          backendConnector.loaded(`${lng}|${ns}`, err, data);
        });
      });
    });
  }
};
Backend.type = "backend";
var lib_default = Backend;
export {
  lib_default as default
};
//# sourceMappingURL=i18next-http-backend.js.map
